<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>缠论可视化 - Web版</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <style>
        body { margin: 0; padding: 0; font-family: sans-serif; background-color: #1e1e1e; color: #ccc; }
        /* 顶部控制栏样式 */
        .controls {
            padding: 10px 20px;
            background-color: #2d2d2d;
            border-bottom: 1px solid #444;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        select, button {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #333;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        select:hover, button:hover { background-color: #444; }
        /* 图表容器 */
        #chart-container {
            width: 100%;
            height: 90vh; /* 占据屏幕高度的 90% */
        }
        /* 加载提示 */
        .loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            display: none;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px 30px;
            border-radius: 8px;
            z-index: 999;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="controls">
        <label>代币:</label>
        <select id="symbol" onchange="fetchData()">
            <option value="BTC">BTC</option>
            <option value="ETH">ETH</option>
            <option value="SOL">SOL</option>
            <option value="XRP">XRP</option>
            <option value="DOGE">DOGE</option>
            <option value="BNB">BNB</option>
        </select>

        <label>周期:</label>
        <select id="interval" onchange="fetchData()">
            <option value="5m">5m</option>
            <option value="15m">15m</option>
            <option value="30m" selected>30m</option>
            <option value="1h">1h</option>
            <option value="2h">2h</option>
            <option value="4h">4h</option>
            <option value="8h">8h</option>
            <option value="1d">1d</option>
            <option value="3d">3d</option>
            <option value="1w">1week</option>
        </select>

        <button onclick="fetchData()">手动刷新</button>
        <span id="status" style="margin-left:auto; font-size: 12px; color: #888;"></span>
    </div>

    <div id="chart-container"></div>
    <div id="loading" class="loading">正在获取数据并计算缠论结构...</div>

    <script>
        // 初始化 ECharts 实例
        var myChart = echarts.init(document.getElementById('chart-container'));
        var option;

        // 监听窗口大小变化，自适应图表
        window.addEventListener('resize', function() {
            myChart.resize();
        });

        // 页面加载完成后立即获取一次数据
        fetchData();

        function fetchData() {
            const symbol = document.getElementById('symbol').value;
            const interval = document.getElementById('interval').value;
            const statusSpan = document.getElementById('status');
            const loading = document.getElementById('loading');

            // 显示加载动画
            loading.style.display = 'block';
            // 简单防抖：可以先把现有图表变灰或者清空，防止误解
            // myChart.clear(); // 如果喜欢切换时闪一下空白，可以取消这行注释
            
            statusSpan.innerText = `正在请求 ${symbol} - ${interval}...`;

            // 请求后端接口，默认请求 2000 条数据以支持历史回看
            fetch(`http://localhost:5000/api/data?symbol=${symbol}&interval=${interval}&limit=2000`)
                .then(response => response.json())
                .then(res => {
                    loading.style.display = 'none';
                    if (res.status === 'success') {
                        statusSpan.innerText = `数据加载成功: ${symbol} ${interval} (共 ${res.data.dates.length} 根)`;
                        renderChart(res.data, symbol, interval);
                    } else {
                        statusSpan.innerText = '错误: 后端未返回数据';
                        alert('未找到数据，请检查后端数据库是否包含该代币数据。');
                    }
                })
                .catch(err => {
                    loading.style.display = 'none';
                    statusSpan.innerText = '连接服务器失败';
                    console.error(err);
                    alert('连接失败，请确保 python server.py 正在运行。');
                });
        }

        function renderChart(data, symbol, interval) {
            const dates = data.dates;
            
            // 计算 DataZoom 的起始位置，默认只显示最后 100 根 K 线
            const total = dates.length;
            const viewCount = 100; 
            const startPercent = total > viewCount ? ((total - viewCount) / total) * 100 : 0;

            // 构造中枢矩形
            const centerAreas = data.centers.map(c => {
                return [
                    { xAxis: c[0], yAxis: c[2], itemStyle: { color: 'rgba(255, 255, 0, 0.15)', borderWidth: 1, borderColor: 'yellow', borderType: 'dashed' } },
                    { xAxis: c[1], yAxis: c[3] }
                ];
            });

            // 构造买卖点标记
            const markPoints = [];
            data.buys.forEach(b => {
                markPoints.push({
                    coord: [b[0], b[1]], value: b[2], itemStyle: { color: '#d900ff' }, 
                    symbol: 'arrow', symbolRotate: 0, symbolOffset: [0, 10], label: { position: 'bottom', formatter: '{b}' }
                });
            });
            data.sells.forEach(s => {
                markPoints.push({
                    coord: [s[0], s[1]], value: s[2], itemStyle: { color: '#00ff00' }, 
                    symbol: 'arrow', symbolRotate: 180, symbolOffset: [0, -10], label: { position: 'top', formatter: '{b}' }
                });
            });

            option = {
                backgroundColor: '#1e1e1e',
                animation: false, // 关闭动画，让切换更跟手
                title: { text: `缠论分析: ${symbol} - ${interval}`, left: 'center', textStyle: { color: '#fff' } },
                tooltip: { trigger: 'axis', axisPointer: { type: 'cross' }, backgroundColor: 'rgba(50,50,50,0.9)', borderColor: '#777', textStyle: { color: '#fff' } },
                axisPointer: { link: { xAxisIndex: 'all' } },
                grid: [
                    { left: '5%', right: '5%', height: '60%', top: '10%' }, 
                    { left: '5%', right: '5%', height: '15%', top: '75%' }
                ],
                xAxis: [
                    { type: 'category', data: dates, gridIndex: 0, axisLine: { lineStyle: { color: '#777' } } },
                    { type: 'category', data: dates, gridIndex: 1, axisLine: { show: false }, axisLabel: { show: false } }
                ],
                yAxis: [
                    { scale: true, gridIndex: 0, axisLine: { lineStyle: { color: '#777' } }, splitLine: { show: true, lineStyle: { color: '#333' } } },
                    { scale: true, gridIndex: 1, axisLine: { lineStyle: { color: '#777' } }, splitLine: { show: false } }
                ],
                // DataZoom 配置
                dataZoom: [
                    { 
                        type: 'inside', 
                        xAxisIndex: [0, 1], 
                        start: startPercent, 
                        end: 100 
                    },
                    { 
                        type: 'slider', 
                        xAxisIndex: [0, 1], 
                        bottom: 10,
                        start: startPercent,
                        end: 100,
                        dataBackground: { lineStyle: { color: '#555' }, areaStyle: { color: '#333' } },
                        selectedDataBackground: { lineStyle: { color: '#fff' }, areaStyle: { color: '#555' } },
                        handleStyle: { color: '#aaa' },
                        textStyle: { color: '#ccc' }
                    }
                ],
                series: [
                    {
                        name: 'KLine', type: 'candlestick', data: data.ohlc,
                        itemStyle: { color: '#ef232a', color0: '#14b143', borderColor: '#ef232a', borderColor0: '#14b143' },
                        markPoint: { data: markPoints, symbolSize: 15 },
                        markArea: { data: centerAreas }
                    },
                    {
                        name: '笔 (Bi)', type: 'line', data: mapLineData(data.bi, dates),
                        smooth: false, showSymbol: true, symbol: 'circle', symbolSize: 4,
                        lineStyle: { color: '#ff4d4d', width: 1.5 }, connectNulls: true
                    },
                    {
                        name: '线段 (Seg)', type: 'line', data: mapLineData(data.segments, dates),
                        smooth: false, showSymbol: true, symbol: 'diamond', symbolSize: 8,
                        lineStyle: { color: '#4d94ff', width: 3 }, connectNulls: true, z: 5
                    },
                    { name: 'DIF', type: 'line', xAxisIndex: 1, yAxisIndex: 1, data: data.macd.diff, lineStyle: { color: '#ffffff', width: 1 }, showSymbol: false },
                    { name: 'DEA', type: 'line', xAxisIndex: 1, yAxisIndex: 1, data: data.macd.dea, lineStyle: { color: '#ffff00', width: 1 }, showSymbol: false },
                    {
                        name: 'MACD', type: 'bar', xAxisIndex: 1, yAxisIndex: 1, data: data.macd.bar,
                        itemStyle: { color: function(params) { return params.value > 0 ? 'rgba(239, 35, 42, 0.5)' : 'rgba(20, 177, 67, 0.5)'; } }
                    }
                ]
            };
            
            // 第二个参数 true 表示不合并，而是完全重置图表（防止不同代币的数据混在一起）
            myChart.setOption(option, true);
        }

        function mapLineData(points, allDates) {
            let result = new Array(allDates.length).fill(null);
            let dateMap = {};
            allDates.forEach((d, i) => dateMap[d] = i);
            points.forEach(p => {
                let timeStr = p[0];
                if (dateMap.hasOwnProperty(timeStr)) {
                    result[dateMap[timeStr]] = p[1];
                }
            });
            return result;
        }
    </script>
</body>
</html>